import {ICourse} from "../typings";

const getTaskHeader = (day: number) => {
  return day === -1 ? 
    `<b>Структуры данных. Курс закончился</b>\n`:
    `<b>Структуры данных. День ${day}</b>\n`;
};

const getFinalText = (userAnswers: [], questions: number) => {
  const correctAnswers = userAnswers.filter((answer) => answer);
  const correctAnswersQuantity = correctAnswers.length;
  let message;

  if (correctAnswersQuantity === questions) {
    message = `Вы правильно ответили на все вопросы! Так держать!`;      
  } else if (correctAnswersQuantity >= Math.floor(questions / 2)) {
    message = `Правильных ответов: ${correctAnswersQuantity} из ${questions}. У вас хороший результат!`; 
  } else {
    message = `Правильных ответов: ${correctAnswersQuantity} из ${questions}. Не огорчайтесь. Наверняка, вы узнали что-то новое! `
  }

  return `${message} 
  
Если захотите ещё раз проверить свои знания, возвращайтесь! Скоро мы добавим новые задания в курс.`
}

const answers: {[index: string]:any} = {
  '1': [
    {
      isCorrect: true,
      content: {
        text: `Правильно! Стек позволяет записывать новые (последние) элементы в конец и получать их в первую очередь. Как с историей браузера: при переходе «назад» мы попадаем на предыдущую посещённую страницу.
    
Стек часто используется для хранения данных. Например, ваши действия в редакторе кода записываются в стек. Вы нажимаете <code>ctrl+z</code> и последнее действие отменяется.
              
Такой принцип называется «последний вошел, первый вышел» (Last-In-First-Out или LIFO). Можно провести аналогию с лифтом. Обычно пассажир, который зашёл позже всех, выходит первым, потому что стоит ближе всех к двери. Ну или с пачкой чипсов Pringles: чтобы добраться до дна упаковки, надо съесть все чипсы сверху (если вы не читер, который высыпает все чипсы в тарелку).`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Не угадали. Очередь — тоже структура данных (о ней поговорим попозже), но правильный ответ — <b>стек</b>.

Стек позволяет записывать новые (последние) элементы в конец и получать их в первую очередь. Как с историей браузера: при переходе «назад» мы попадаем на предыдущую посещённую страницу.
      
Стек часто используется для хранения данных. Например, ваши действия в редакторе кода записываются в стек. Вы нажимаете <code>ctrl+z</code> и последнее действие отменяется.
      
Такой принцип называется «последний вошел, первый вышел» (Last-In-First-Out или LIFO). Можно провести аналогию с лифтом. Обычно пассажир, который зашёл позже всех, выходит первым, потому что стоит ближе всех к двери. Ну или с пачкой чипсов Pringles: чтобы добраться до дна упаковки, надо съесть все чипсы сверху (если вы не читер, который высыпает все чипсы в тарелку).
      
А очередь работает наоборот, по принципу «первый пришёл — первый вышел» (FIFO, First In — First Out).`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Не угадали. Дерево — тоже структура данных, но правильный ответ — <b>стек</b>.

Стек позволяет записывать новые (последние) элементы в конец и получать их в первую очередь. Как с историей браузера: при переходе «назад» мы попадаем на предыдущую посещённую страницу.
              
Стек часто используется для хранения данных. Например, ваши действия в редакторе кода записываются в стек. Вы нажимаете <code>ctrl+z</code> и последнее действие отменяется.
              
Такой принцип называется «последний вошел, первый вышел» (Last-In-First-Out или LIFO). Можно провести аналогию с лифтом. Обычно пассажир, который зашёл позже всех, выходит первым, потому что стоит ближе всех к двери. Ну или с пачкой чипсов Pringles: чтобы добраться до дна упаковки, надо съесть все чипсы сверху (если вы не читер, который высыпает все чипсы в тарелку).`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Ничего, сейчас разберёмся! Правильный ответ — <b>стек</b>.

Стек позволяет записывать новые (последние) элементы в конец и получать их в первую очередь. Как с историей браузера: при переходе «назад» мы попадаем на предыдущую посещённую страницу.
              
Стек часто используется для хранения данных. Например, ваши действия в редакторе кода записываются в стек. Вы нажимаете <code>ctrl+z</code> и последнее действие отменяется.
        
Такой принцип называется «последний вошел, первый вышел» (Last-In-First-Out или LIFO). Можно провести аналогию с лифтом. Обычно пассажир, который зашёл позже всех, выходит первым, потому что стоит ближе всех к двери. Ну или с пачкой чипсов Pringles: чтобы добраться до дна упаковки, надо съесть все чипсы сверху (если вы не читер, который высыпает все чипсы в тарелку).`
      }
    }
  ],

  '2': [
    {
      isCorrect: false,
      content: {
        text: `Не угадали. Метод <code>pop</code> удаляет последний элемент массива и возвращает его значение. Его можно использовать для получения элементов из стека. 

А что с другими вариантами? Метод <code>unshift</code> записывает новые элементы в начало массива, а в стеке обычно новые элементы записываются в конец. Помните, «последний пришёл, первый вышел»? 
      
Зато метод <code>push</code> записывает новые элементы в конец массива. То,что нужно для стека!
      
В целом вы можете использовать <code>unshift</code>, чтобы записывать новые данные в начало массива. А потом и брать элементы из начала, но это не оптимально для производительности. С добавлением и удалением каждого элемента, массив будет сдвигаться, будут пересчитываться индексы всех элементов.`
      }
    },
    {
      isCorrect: true,
      content: {
        text: `Да, всё верно! Метод <code>push</code> добавляет новые элементы в конец массива. То, что нужно для стека!
      
А что с другими вариантами? Метод <code>pop</code> удаляет последний элемент массива и возвращает его значение. Его можно использовать для получения элементов из стека. Метод <code>unshift</code> записывает новые элементы в начало массива. А в стеке обычно новые элементы записываются в конец. Помните, «последний пришёл, первый вышел»?

В целом вы можете записывать новые данные в начало массива и брать элементы оттуда, но это не оптимально для производительности. С добавлением и удалением каждого элемента, массив будет сдвигаться, будут пересчитываться индексы всех элементов.`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Почти. Метод <code>unshift</code> записывает новые элементы в начало массива. А в стеке обычно новые элементы записываются в конец. Помните, «последний пришёл, первый вышел»? Поэтому здесь лучше всего подойдёт метод <code>push</code>, который записывает новые элементы в конец массива.

В целом вы можете записывать новые данные в начало массива и брать элементы оттуда, но это не оптимально для производительности. С добавлением и удалением каждого элемента, массив будет сдвигаться, будут пересчитываться индексы всех элементов.

А что насчёт метода <code>pop</code>? Он удаляет последний элемент массива и возвращает его значение. Его можно использовать для получения элементов из стека.`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Ничего, сейчас всё будет! Посмотрим на все предложенные методы

Метод <code>pop</code> удаляет последний элемент массива и возвращает его значение. Его можно использовать для получения элементов из стека. 
      
Метод <code>unshift</code> записывает новые элементы в начало массива, а в стеке обычно новые элементы записываются в конец. Помните, «последний пришёл, первый вышел»? 
      
Зато метод <code>push</code> записывает новые элементы в конец массива. То, что нужно для стека!
      
В целом вы можете использовать <code>unshift</code>, чтобы записывать новые данные в начало массива. А потом и брать элементы из начала, но это не оптимально для производительности. С добавлением и удалением каждого элемента, массив будет сдвигаться, будут пересчитываться индексы всех элементов.`
      }
    }
  ],

  '3': [
    {
      isCorrect: true,
      content: {
        text: `Да! Именно метод <code>pop</code> нам и нужен, чтобы получить последние добавленные в массив элементы. Метод удаляет последний элемент массива и возвращает его значение.

А для чего остальные методы? Метод <code>push</code>, как вы уже знаете из предыдущего вопроса, записывает новые элементы в конец массива. Он подходит для добавления элементов в стек, а не получения.
      
Метод <code>shift</code> удаляет первый элемент из массива и возвращает его значение. Для стека это не очень подходит — новые элементы записываются в конец, поэтому и получать их надо из конца массива.

В целом вы можете записывать новые данные в начало массива и брать элементы оттуда, но это не оптимально для производительности. С добавлением и удалением каждого элемента, массив будет сдвигаться, будут пересчитываться индексы всех элементов.`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Неа. Метод <code>push</code>, как вы уже знаете из предыдущего вопроса, занимается записью элементов в массив, а вот <code>pop</code> удаляет последний элемент из массива и возвращает его значение.

А что делает метод <code>shift</code>? Он удаляет первый элемент из массива и возвращает его значение. Для стека это не очень подходит — новые элементы записываются в конец, поэтому и получать их надо из конца массива.

В целом вы можете записывать новые данные в начало массива и брать элементы оттуда, но это не оптимально для производительности. С добавлением и удалением каждого элемента, массив будет сдвигаться, будут пересчитываться индексы всех элементов.`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Почти, но нет. Метод <code>shift</code> удаляет первый элемент из массива и возвращает его значение. Для стека это не очень подходит — новые элементы записываются в конец, поэтому и получать элементы надо из конца массива. Для этого подходит метод <code>pop</code> — он удаляет последний элемент массива и возвращает его значение.

В целом вы можете записывать новые данные в начало массива и брать элементы оттуда, но это не оптимально для производительности. С добавлением и удалением каждого элемента, массив будет сдвигаться, будут пересчитываться индексы всех элементов.

Метод <code>push</code>, как вы уже знаете из предыдущего вопроса, записывает новые элементы в конец массива и подходит для добавления элементов в стек, а не получения.`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Ничего! Помните, стек работает по принципу «последний пришёл, первый вышел»? Новые элементы записываются в конец стека, в нашем случае массива. Поэтому и получать последние добавленные элементы надо из конца массива. Для этого подходит метод <code>pop</code> — он удаляет последний элемент массива и возвращает его значение.
      
А для чего остальные методы? Метод <code>shift</code> удаляет первый элемент из массива и возвращает его значение. Для стека это не очень подходит — новые элементы записываются в конец, поэтому и получать их надо из конца массива.

В целом вы можете записывать новые данные в начало массива и брать элементы оттуда, но это не оптимально для производительности. С добавлением и удалением каждого элемента, массив будет сдвигаться, будут пересчитываться индексы всех элементов.

Про метод <code>push</code> вы уже знаете из предыдущего вопроса. Он записывает новые элементы в конец массива и подходит для добавления элементов в стек, а не их получения.`
      }
    }
  ],

  '4': [
    {
      isCorrect: false,
      content: {
        text: `Звучит неплохо, но нет. Такой механизм называется <b>стеком вызовов</b> (call stack) или стеком выполнения. Давайте разбираться на примере, как он работает. У нас есть такой фрагмент кода (да, он простой, чтобы было проще разобраться, подыграйте):
      
<pre><code>const countPlates = (guests) => { 
  return guests * 2; 
};
const createDinner = (guests) => { 
  return &#715;Для \${guests} гостей надо 
  приготовить \${countPlates(guests)} тарелок&#715; 
};
      
console.log(createDinner(7)); 
// Для 7 гостей надо 
// приготовить 14 тарелок</code></pre>
      
JavaScript выделяет глобальный контекст выполнения — в нём выполняется весь наш скрипт. Затем он разбирает наш код построчно, сверху вниз. Сначала он фиксирует объявление двух функций (<code>createDinner</code> и <code>countPlates</code>).

После этого JS встречает вызов <code>console.log</code>. Действие этого вызова приостанавливается. Да, вывод в консоль не срабатывает сразу. Движок создаёт <b>контекст выполнения</b> для этой функции. В нём находится информация о конкретном месте функции в коде, локальные переменные функции, значение <code>this</code> и другие служебные данные. Этот контекст помещается в стек вызовов.

Дальше движок встречает вложенный вызов функции <code>createDinner</code>. Для неё происходит всё то же самое, что и для вывода в консоль: вызов приостанавливается, создаётся контекст вызова функции и помещается в стек вызовов. Прямо после контекста <code>console.log</code>.

Потом то же самое происходит для функции <code>countPlates</code>, которая вызывается из функции <code>createDinner</code>.

В итоге в стеке три контекста. В самом начале <code>console.log</code>, потом <code>сreateDinner</code> и в конце <code>countPlates</code>.

Когда все контексты найдены и собраны в стек, движок начинает разматывать клубок: сначала проиcходит вызов последней функции в стопке — <code>countPlates</code>. После выполнения кода, контекст этой функции достаётся из стека. А результат передаётся в контекст следующей функции — <code>createDinner</code>. Эта функция срабатывает, её контекст удаляется из стека, и, наконец-то, происходит вывод в консоль. Такие дела.

Можно представить аналогию со стопкой блинов. Новые блины (они же контексты вызова функций) кладутся наверх стопки. И чтобы добраться до нижних блинов, надо убрать блины сверху.`
      }
    },
    {
      isCorrect: true,
      content: {
        text: `Верно! Стек вызовов хранит контексты выполнения функций. Чем больше вложенных функций, там больше данных в стеке. Движок разбирает эти контексты с конца, постепенно удаляя уже вызванные функции.
      
Рассмотрим по шагам. У нас есть такой фрагмент кода (да, он простой, чтобы было проще разобраться, подыграйте):
      
<pre><code>const countPlates = (guests) => { 
  return guests * 2; 
};
const createDinner = (guests) => { 
  return &#715;Для \${guests} гостей надо 
  приготовить \${countPlates(guests)} тарелок&#715; 
};
      
console.log(createDinner(7)); 
// Для 7 гостей надо 
// приготовить 14 тарелок</code></pre>
      
JavaScript выделяет глобальный контекст выполнения — в нём выполняется весь наш скрипт. Затем он разбирает наш код построчно, сверху вниз. Сначала он фиксирует объявление двух функций (<code>createDinner</code> и <code>countPlates</code>).

После этого JS встречает вызов <code>console.log</code>. Действие этого вызова приостанавливается. Да, вывод в консоль не срабатывает сразу. Движок создаёт <b>контекст выполнения</b> для этой функции. В нём находится информация о конкретном месте функции в коде, локальные переменные функции, значение <code>this</code> и другие служебные данные. Этот контекст помещается в стек вызовов.

Дальше движок встречает вложенный вызов функции <code>createDinner</code>. Для неё происходит всё то же самое, что и для вывода в консоль: вызов приостанавливается, создаётся контекст вызова функции и помещается в стек вызовов. Прямо после контекста <code>console.log</code>.

Потом то же самое происходит для функции <code>countPlates</code>, которая вызывается из функции <code>createDinner</code>.

В итоге в стеке три контекста. В самом начале <code>console.log</code>, потом <code>сreateDinner</code> и в конце <code>countPlates</code>.

Когда все контексты найдены и собраны в стек, движок начинает разматывать клубок: сначала проиcходит вызов последней функции в стопке — <code>countPlates</code>. После выполнения кода, контекст этой функции достаётся из стека. А результат передаётся в контекст следующей функции — <code>createDinner</code>. Эта функция срабатывает, её контекст удаляется из стека, и, наконец-то, происходит вывод в консоль. Такие дела.

Можно представить аналогию со стопкой блинов. Новые блины (они же контексты вызова функций) кладутся наверх стопки. И чтобы добраться до нижних блинов, надо убрать блины сверху.`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Хорошая версия, но нет. Такой механизм называется <b>стеком вызовов</b> (call stack) или стеком выполнения.

Давайте разбираться на примере, как он работает. У нас есть такой фрагмент кода (да, он простой, чтобы было проще разобраться, подыграйте):
      
<pre><code>const countPlates = (guests) => { 
  return guests * 2; 
};
const createDinner = (guests) => { 
  return &#715;Для \${guests} гостей надо 
  приготовить \${countPlates(guests)} тарелок&#715; 
};
      
console.log(createDinner(7)); 
// Для 7 гостей надо 
// приготовить 14 тарелок</code></pre>
      
JavaScript выделяет глобальный контекст выполнения — в нём выполняется весь наш скрипт. Затем он разбирает наш код построчно, сверху вниз. Сначала он фиксирует объявление двух функций (<code>createDinner</code> и <code>countPlates</code>).

После этого JS встречает вызов <code>console.log</code>. Действие этого вызова приостанавливается. Да, вывод в консоль не срабатывает сразу. Движок создаёт <b>контекст выполнения</b> для этой функции. В нём находится информация о конкретном месте функции в коде, локальные переменные функции, значение <code>this</code> и другие служебные данные. Этот контекст помещается в стек вызовов.

Дальше движок встречает вложенный вызов функции <code>createDinner</code>. Для неё происходит всё то же самое, что и для вывода в консоль: вызов приостанавливается, создаётся контекст вызова функции и помещается в стек вызовов. Прямо после контекста <code>console.log</code>.

Потом то же самое происходит для функции <code>countPlates</code>, которая вызывается из функции <code>createDinner</code>.

В итоге в стеке три контекста. В самом начале <code>console.log</code>, потом <code>сreateDinner</code> и в конце <code>countPlates</code>.

Когда все контексты найдены и собраны в стек, движок начинает разматывать клубок: сначала проиcходит вызов последней функции в стопке — <code>countPlates</code>. После выполнения кода, контекст этой функции достаётся из стека. А результат передаётся в контекст следующей функции — <code>createDinner</code>. Эта функция срабатывает, её контекст удаляется из стека, и, наконец-то, происходит вывод в консоль. Такие дела.

Можно представить аналогию со стопкой блинов. Новые блины (они же контексты вызова функций) кладутся наверх стопки. И чтобы добраться до нижних блинов, надо убрать блины сверху.`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Давайте разбираться! Такой механизм называется <b>стеком вызовов</b> (call stack) или стеком выполнения. Посмотрим на примере, как он работает. У нас есть такой фрагмент кода (да, он простой, чтобы было проще разобраться, подыграйте):
      
<pre><code>const countPlates = (guests) => { 
  return guests * 2; 
};
const createDinner = (guests) => { 
  return &#715;Для \${guests} гостей надо 
  приготовить \${countPlates(guests)} тарелок&#715; 
};
      
console.log(createDinner(7)); 
// Для 7 гостей надо 
// приготовить 14 тарелок</code></pre>
      
JavaScript выделяет глобальный контекст выполнения — в нём выполняется весь наш скрипт. Затем он разбирает наш код построчно, сверху вниз. Сначала он фиксирует объявление двух функций (<code>createDinner</code> и <code>countPlates</code>).

После этого JS встречает вызов <code>console.log</code>. Действие этого вызова приостанавливается. Да, вывод в консоль не срабатывает сразу. Движок создаёт <b>контекст выполнения</b> для этой функции. В нём находится информация о конкретном месте функции в коде, локальные переменные функции, значение <code>this</code> и другие служебные данные. Этот контекст помещается в стек вызовов.

Дальше движок встречает вложенный вызов функции <code>createDinner</code>. Для неё происходит всё то же самое, что и для вывода в консоль: вызов приостанавливается, создаётся контекст вызова функции и помещается в стек вызовов. Прямо после контекста <code>console.log</code>.

Потом то же самое происходит для функции <code>countPlates</code>, которая вызывается из функции <code>createDinner</code>.

В итоге в стеке три контекста. В самом начале <code>console.log</code>, потом <code>сreateDinner</code> и в конце <code>countPlates</code>.

Когда все контексты найдены и собраны в стек, движок начинает разматывать клубок: сначала проиcходит вызов последней функции в стопке — <code>countPlates</code>. После выполнения кода, контекст этой функции достаётся из стека. А результат передаётся в контекст следующей функции — <code>createDinner</code>. Эта функция срабатывает, её контекст удаляется из стека, и, наконец-то, происходит вывод в консоль. Такие дела.

Можно представить аналогию со стопкой блинов. Новые блины (они же контексты вызова функций) кладутся наверх стопки. И чтобы добраться до нижних блинов, надо убрать блины сверху.`
      }
    }
  ],

  '5': [
    {
      isCorrect: false,
      content: {
        text: `Не угадали. Со стеком мелодия будет проигрываться задом наперёд — с конца в начало. Помните, стек работает по принципу «последний вошел, первый вышел»? А для нашей задачи мелодия должна играть привычным способом — с начала и до конца. Тут подойдёт <b>очередь</b>.

Очередь позволяет записывать новые элементы в конец и получать их после остальных — в порядке очереди. Как в задаче с музыкой — последняя нота будет и проиграна последней.
      
А ещё очередь используется в движке JavaScript — события, которые нужно выполнить, выстраиваются в очередь. Такая очередь называется «очередью макрозадач» (macrotask queue).
      
Очередь работает по принципу «первый пришёл — первый вышел» (First In — First Out или FIFO). Можно провести аналогию с любой привычной нам очередью: в банке или в больнице. Первый в очереди первым и зайдёт. А вот внезапно ворваться с «только спросить» тут не получится.`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Ничего, сейчас узнаете! Правильный ответ — <b>очередь</b>.

Очередь позволяет записывать новые элементы в конец и получать их после остальных — в порядке очереди. Как в задаче с музыкой — последняя нота будет и проиграна последней.
      
А ещё очередь используется в движке JavaScript — события, которые нужно выполнить, выстраиваются в очередь. Такая очередь называется «очередью макрозадач» (macrotask queue).
      
Очередь работает по принципу «первый пришёл — первый вышел» (First In — First Out или FIFO). Можно провести аналогию с любой привычной нам очередью: в банке или в больнице. Первый в очереди первым и зайдёт. А вот внезапно ворваться с «только спросить» тут не получится.

Почему для решения не подойдёт стек? Со стеком мелодия будет проигрываться задом наперёд — с конца в начало. Помните, стек работает по принципу «последний вошел, первый вышел»? А для нашей задачи мелодия должна играть привычным способом — с начала и до конца.`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Не угадали. До хеш-таблиц мы ещё доберёмся в будущем, это очень полезная структура данных. Но в этой задаче правильный ответ — <b>очередь</b>.

Очередь позволяет записывать новые элементы в конец и получать их после остальных — в порядке очереди. Как в задаче с музыкой — последняя нота будет и проиграна последней.
      
А ещё очередь используется в движке JavaScript — события, которые нужно выполнить, выстраиваются в очередь. Такая очередь называется «очередью макрозадач» (macrotask queue).
      
Очередь работает по принципу «первый пришёл — первый вышел» (First In — First Out или FIFO). Можно провести аналогию с любой привычной нам очередью: в банке или в больнице. Первый в очереди первым и зайдёт. А вот внезапно ворваться с «только спросить» тут не получится.

Почему для решения не подойдёт стек? Со стеком мелодия будет проигрываться задом наперёд — с конца в начало. Помните, стек работает по принципу «последний вошел, первый вышел»? А для нашей задачи мелодия должна играть привычным способом — с начала и до конца.`
      }
    },
    {
      isCorrect: true,
      content: {
        text: `Верно! Очередь позволяет записывать новые элементы в конец и получать их после остальных — в порядке очереди. Как в задаче с музыкой — последняя нота будет и проиграна последней. Такой принцип называется «первый пришёл — первый вышел» (First In — First Out или FIFO).

А ещё очередь используется в движке JavaScript — события, которые нужно выполнить, выстраиваются в очередь. Такая очередь называется «очередью макрозадач» (macrotask queue).

Почему для решения не подойдёт стек? Со стеком мелодия будет проигрываться задом наперёд — с конца в начало. Помните, стек работает по принципу «последний вошел, первый вышел»? А для нашей задачи мелодия должна играть привычным способом — с начала и до конца.`
      }
    }
  ],

  '6': [
    {
      isCorrect: false,
      content: {
        text: `Неа. Метод <code>pop</code> удаляет последний элемент массива и возвращает его значение. Его можно использовать для получения элементов из стека. Мы разбирали это в третьем вопросе. 
      
А вот записывает новый элемент в конец массива метод <code>push</code>. Помните, все новички встают в конец очереди? Тут всё по-честному — «первый пришёл — первый вышел».

Обратите внимание, что для записи новых элементов в очередь и стек можно использовать одинаковый метод.

А что насчёт <code>unshift</code>? Этот метод записывает новые элементы в начало массива. А в очереди, как и в стеке, новые элементы обычно записываются в конец. Здесь всё, как в настоящей очереди в магазине. Пришёл последним — вставай за всеми.`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Не угадали. Метод <code>unshift</code> записывает новые элементы в начало массива. А в очереди, как и в стеке, новые элементы обычно записываются в конец. Здесь всё, как в настоящей очереди в магазине. Пришёл последним — вставай за всеми. Поэтому лучше всего подойдёт метод <code>push</code>, который записывает новые элементы в конец массива.
      
А что насчёт <code>pop</code>? Этот метод удаляет последний элемент массива и возвращает его значение. Его можно использовать для получения элементов из стека. Мы разбирали это в третьем вопросе.`
      }
    },
    {
      isCorrect: true,
      content: {
        text: `Бинго! Метод <code>push</code> добавляет новые элементы в конец массива. То, что нужно для очереди! И для стека.
      
А что насчёт <code>pop</code>? Этот метод удаляет последний элемент массива и возвращает его значение. Его можно использовать для получения элементов из стека. Мы разбирали это в третьем вопросе.

А <code>unshift</code>? Метод записывает новые элементы в начало массива. А в очереди, как и в стеке, новые элементы обычно записываются в конец. Здесь всё, как в настоящей очереди в магазине. Пришёл последним — вставай за всеми.`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Давайте выяснять! Помните, очередь работает по принципу «первый пришёл — первый вышел»? Это значит, что новички, которые «пришли» позже всех, встают в конец очереди, то есть в конец массива. Поэтому здесь лучше всего подойдёт метод <code>push</code>, который как раз и записывает новые элементы в конец массива.
    
А что насчёт <code>pop</code>? Этот метод удаляет последний элемент массива и возвращает его значение. Его можно использовать для получения элементов из стека. Мы разбирали это в третьем вопросе.

А <code>unshift</code>? Метод записывает новые элементы в начало массива. А в очереди, как и в стеке, новые элементы обычно записываются в конец. Здесь всё, как в настоящей очереди в магазине. Пришёл последним — вставай за всеми.`
      }
    }
  ],

  '7': [
    {
      isCorrect: false,
      content: {
        text: `Нет. Метод <code>pop</code> удаляет последний элемент массива и возвращает его значение. Это отлично работает для стека, но не для очереди.

В очереди первые элементы «пришли» раньше остальных и должны удаляться первыми. Значит, нужен метод, который удаляет первый элемент массива и возвращает его значение. Это метод <code>shift</code>.

Ну а про <code>push</code> вы уже знаете. Он добавляет новые элементы в конец массива, а не удаляет их.`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Неа. Метод <code>push</code> занимается записью элементов в конец массива, а нам нужно получать первые элементы. Помните, «первый пришёл, первый вышел»? Поэтому тут нужен метод <code>shift</code>, который удаляет первый элемент массива и возвращает его значение.
      
Почему не <code>pop</code>? Он удаляет последний элемент массива и возвращает его значение. Это отлично работает для стека, но не для очереди.`
      }
    },
    {
      isCorrect: true,
      content: {
        text: `Верно! То, что нужно! Именно этот метод удаляет первый элемент массива и возвращает его значение.
      
Почему не <code>pop</code>? Он удаляет последний элемент массива и возвращает его значение. Это отлично работает для стека, но не для очереди.

Ну а про <code>push</code> вы уже знаете. Он добавляет новые элементы в конец массива, а не удаляет их.`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Давайте узнавать!
В очереди первые элементы «пришли» раньше остальных и должны удаляться первыми. Значит, нужен метод, который может удалить первый элемент массива и вернуть его значение. Это метод <code>shift</code>.

Почему не <code>pop</code>? Он удаляет последний элемент массива и возвращает его значение. Это отлично работает для стека, но не для очереди.

Ну а про push вы уже знаете. Он добавляет новые элементы в конец массива, а не удаляет их.`
      }
    }
  ],

  '8': [
    {
      isCorrect: false,
      content: {
        text: `Почти, но не совсем. Речь шла о связном списке.
В JS для связных списков, да и вообще списков, используют <a href="https://learn.javascript.ru/object">объекты</a>.

Но положить объект в объект недостаточно, чтобы получился <b>связный</b> список. Особенность этого списка в том, что каждый элемент является указателем на следующий элемент этого же списка. Получается цепочка элементов. 
      
Любую последовательность действий можно записать в виде связного списка. Например, рецепт приготовления блинов.

<pre><code>{
  name: 'взять глубокую миску',
  next: {
    name: 'взять два яйца',
    next: {
      name: 'разбить два яйца в миску',
      next: {
        name: 'взять 500 мл молока',
        next: {
          name: 'налить молоко в миску к яйцам',
          next: {
            // и так далее
          }
        }
      }
    }
  }
}</code></pre>

Получается цепочка действий: взять глубокую миску → взять два яйца → разбить два яйца в миску → взять 500 мл молока → налить молоко в миску к яйцам ...

А обычный объект, внутри которого просто лежат другие объекты без указания друг на друга, связным списком не является, это просто объект.

<pre><code>{
  name: crepes,
  ingredients: {
    eggs: 2,
    milk: 500
    sugar: 3
  },
  recipe: {
    stage1: 'взять глубокую миску',
    stage2: 'взять яйца',
    stage3: 'разбить яйца в миску'
  }
}</code></pre>

Объекты внутри связаны одной сущностью — блинами, но последовательных действий тут нет. Можно, конечно, пронумеровать некоторые ключи, написать алгоритм, который будет читать значения из них по порядку, но ведь с объектами так не работают, правда?

<i>Если вам кажется, что для записи последовательных команд подходят массивы, вам не кажется. В зависимости от задачи используют либо их, либо связные списки (либо кое-что ещё). Но об этом позже. Не будем забегать вперёд.</i>

В самом JS тоже есть примеры связанных списков. Например, цепочка прототипов.

<pre><code>{ 
  something: 'something',
  _proto_: {
    anything: 'anything',
    _proto_: {
      everything: 'everything',
      _proto_: {
        // и так далее
    }
  }
}</code></pre>

Обратите внимание на название структуры. На русском можно встретить как «связный список», так и «связанный список», а на английском структура зовётся Linked list. Ещё такой список можно назвать однонаправленным.`
      }
    },
    {
      isCorrect: true,
      content: {
        text: `Бинго! 

Ещё можно встретить название «связанный список», а на английском структура называется Linked list. Такой список так же можно назвать однонаправленным.
      
В JS для связных списков, да и вообще списков, используют <a href="https://learn.javascript.ru/object">объекты</a>.
      
Но положить объект в объект недостаточно, чтобы получить <b>связный</b> список. Особенность этого списка в том, что каждый элемент является указателем на следующий элемент этого же списка. Получается цепочка элементов. 
      
Любую последовательность действий можно записать в виде связного списка. Например, рецепт приготовления блинов.

<pre><code>{
  name: 'взять глубокую миску',
  next: {
    name: 'взять два яйца',
    next: {
      name: 'разбить два яйца в миску',
      next: {
        name: 'взять 500 мл молока',
        next: {
          name: 'налить молоко в миску к яйцам',
          next: {
            // и так далее
          }
        }
      }
    }
  }
}</code></pre>

Получается цепочка действий: взять глубокую миску → взять два яйца → разбить два яйца в миску → взять 500 мл молока → налить молоко в миску к яйцам ...

А обычный объект, внутри которого просто лежат другие объекты без указания друг на друга, связным списком не является, это просто объект.

<pre><code>{
  name: crepes,
  ingredients: {
    eggs: 2,
    milk: 500
    sugar: 3
  },
  recipe: {
    stage1: 'взять глубокую миску',
    stage2: 'взять яйца',
    stage3: 'разбить яйца в миску'
  }
}</code></pre>

Объекты внутри связаны одной сущностью — блинами, но последовательных действий тут нет. Можно, конечно, пронумеровать некоторые ключи, написать алгоритм, который будет читать значения из них по порядку, но ведь с объектами так не работают, правда?

<i>Если вам кажется, что для записи последовательных команд подходят массивы, вам не кажется. В зависимости от задачи используют либо их, либо связные списки (либо кое-что ещё). Но об этом позже. Не будем забегать вперёд.</i>

В самом JS тоже есть примеры связанных списков. Например, цепочка прототипов.

<pre><code>{ 
  something: 'something',
  _proto_: {
    anything: 'anything',
    _proto_: {
      everything: 'everything',
      _proto_: {
        // и так далее
    }
  }
}</code></pre>`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Почти, речь шла о связном списке. 

Связным список становится именно тогда, каждый каждый элемент (он же <a href="https://learn.javascript.ru/object">объект</a>), кроме информации о себе, содержит ссылку на соседний элемент этого списка. В теории может быть непонятно, поэтому посмотрим примеры.
      
Любую последовательность действий можно записать в виде связного списка. Например, рецепт приготовления блинов.

<pre><code>{
  name: 'взять глубокую миску',
  next: {
    name: 'взять два яйца',
    next: {
      name: 'разбить два яйца в миску',
      next: {
        name: 'взять 500 мл молока',
        next: {
          name: 'налить молоко в миску к яйцам',
          next: {
            // и так далее
          }
        }
      }
    }
  }
}</code></pre>

Получается цепочка действий: взять глубокую миску → взять два яйца → разбить два яйца в миску → взять 500 мл молока → налить молоко в миску к яйцам ...

А обычный объект, внутри которого просто лежат другие объекты без указания друг на друга, связным списком не является, это просто объект.

<pre><code>{
  name: crepes,
  ingredients: {
    eggs: 2,
    milk: 500
    sugar: 3
  },
  recipe: {
    stage1: 'взять глубокую миску',
    stage2: 'взять яйца',
    stage3: 'разбить яйца в миску'
  }
}</code></pre>

Объекты внутри связаны одной сущностью — блинами, но последовательных действий тут нет. Можно, конечно, пронумеровать некоторые ключи, написать алгоритм, который будет читать значения из них по порядку, но ведь с объектами так не работают, правда?

<i>Если вам кажется, что для записи последовательных команд подходят массивы, вам не кажется. В зависимости от задачи используют либо их, либо связные списки (либо кое-что ещё). Но об этом позже. Не будем забегать вперёд.</i>

В самом JS тоже есть примеры связанных списков. Например, цепочка прототипов.

<pre><code>{ 
  something: 'something',
  _proto_: {
    anything: 'anything',
    _proto_: {
      everything: 'everything',
      _proto_: {
        // и так далее
    }
  }
}</code></pre>

Обратите внимание на название структуры. На русском можно встретить как «связный список», так и «связанный список», а на английском структура зовётся как Linked list. Ещё такой список можно назвать однонаправленным.`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Сейчас разберёмся! Правильный ответ: связный список.

Ещё можно встретить название «связанный список», а на английском структура называется Linked list. Такой список так же можно называть однонаправленным.
      
В JS для связных списков, да и вообще списков, используют <a href="https://learn.javascript.ru/object">объекты</a>.
      
Положить объект в объект недостаточно, чтобы получить <b>связный</b> список. Особенность этого списка в том, что каждый элемент является указателем на следующий элемент этого же списка. Получается цепочка элементов. 
      
Любую последовательность действий можно записать в виде связного списка. Например, рецепт приготовления блинов.

<pre><code>{
  name: 'взять глубокую миску',
  next: {
    name: 'взять два яйца',
    next: {
      name: 'разбить два яйца в миску',
      next: {
        name: 'взять 500 мл молока',
        next: {
          name: 'налить молоко в миску к яйцам',
          next: {
            // и так далее
          }
        }
      }
    }
  }
}</code></pre>

Получается цепочка действий: взять глубокую миску → взять два яйца → разбить два яйца в миску → взять 500 мл молока → налить молоко в миску к яйцам ...

А обычный объект, внутри которого просто лежат другие объекты без указания друг на друга, связным списком не является, это просто объект.

<pre><code>{
  name: crepes,
  ingredients: {
    eggs: 2,
    milk: 500
    sugar: 3
  },
  recipe: {
    stage1: 'взять глубокую миску',
    stage2: 'взять яйца',
    stage3: 'разбить яйца в миску'
  }
}</code></pre>

Объекты внутри связаны одной сущностью — блинами, но последовательных действий тут нет. Можно, конечно, пронумеровать некоторые ключи, написать алгоритм, который будет читать значения из них по порядку, но ведь с объектами так не работают, правда?

<i>Если вам кажется, что для записи последовательных команд подходят массивы, вам не кажется. В зависимости от задачи используют либо их, либо связные списки (либо кое-что ещё). Но об этом позже. Не будем забегать вперёд.</i>

В самом JS тоже есть примеры связанных списков. Например, цепочка прототипов.

<pre><code>{ 
  something: 'something',
  _proto_: {
    anything: 'anything',
    _proto_: {
      everything: 'everything',
      _proto_: {
        // и так далее
    }
  }
}</code></pre>
`
      }
    }
  ],

  '9': [
    {
      isCorrect: false,
      content: {
        text: `Почти. Связный список состоит из объектов, поэтому значение мы, конечно, получим по ключу. Но так же быстро, как в обычном объекте, не получится.

Тут важно понять разницу между простым объектом и списком. Объект — самостоятельный тип данных, из которого, как из конструктора, можно собрать абстрактные структуры данных. Например, связные списки. Давайте посмотрим на обычный объект, в котором нет ссылок на другие объекты. И сравним его со связным списком.

<pre><code>let adress = {
  street: 'Ленина',
  number: 56,
  city: 'Москва'
}

console.log(adress['street']); 
// Выведет 'Ленина'</code></pre>

В таком объекте мы легко можем получить значение любого элемента, достаточно знать ключ. А что со связным списком? Например, если с его помощью мы составили маршрут.

<pre><code>let route = {
  street: 'Итальянская',
  number: 20,
  next: {
    street: 'Тореза',
    number: 17,
    next: {
      street: 'Ленина',
      number: 56,
      next: {
        // и так далее
      }
    }
  }
}

console.log(route['next']['next']['street']);
// Выведет 'Ленина'</code></pre>

Мы не можем просто так узнать, какая улица будет третьей. Сначала надо добраться до того объекта, где записана эта улица и только потом получить её название. В общем-то это похоже на настоящий маршрут. Если бы мы шли пешком по маршруту, описанному в списке выше, мы бы не смогли сразу попасть на улицу Ленина, не пройдя по Итальянской и Тореза. Так и работают связные списки: чтобы добраться до какого-то из объектов, надо сначала перебрать все предыдущие, обходных путей нет.`
      }
    },
    {
      isCorrect: true,
      content: {
        text: `Верно!

Связный список состоит из объектов, поэтому значение мы, конечно, получим по ключу. Но так же быстро, как в обычном объекте, не получится.

Тут важно понять разницу между простым объектом и списком. Объект — самостоятельный тип данных, из которого, как из конструктора, можно собрать абстрактные структуры данных. Например, связные списки. Давайте посмотрим на обычный объект, в котором нет ссылок на другие объекты. И сравним его со связным списком.
      
<pre><code>let adress = {
  street: 'Ленина',
  number: 56,
  city: 'Москва'
}

console.log(adress['street']); 
// Выведет 'Ленина'</code></pre>
      
В таком объекте мы легко можем получить значение любого элемента, достаточно знать ключ. А что со связным списком? Например, если с его помощью мы составили маршрут.

<pre><code>let route = {
  street: 'Итальянская',
  number: 20,
  next: {
    street: 'Тореза',
    number: 17,
    next: {
      street: 'Ленина',
      number: 56,
      next: {
        // и так далее
      }
    }
  }
}

console.log(route['next']['next']['street']);
// Выведет 'Ленина'</code></pre>

Мы не можем просто так узнать, какая улица будет третьей. Сначала надо добраться до того объекта, где записана эта улица и только потом получить её название. В общем-то это похоже на настоящий маршрут. Если бы мы шли пешком по маршруту, описанному в списке выше, мы бы не смогли сразу попасть на улицу Ленина, не пройдя по Итальянской и Тореза. Так и работают связные списки: чтобы добраться до какого-то из объектов, надо сначала перебрать все предыдущие, обходных путей нет.`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Не будем так категоричны. Связный список состоит из объектов, поэтому значение мы, конечно, получим по ключу. Но так же быстро, как в обычном объекте, не получится.

Тут важно понять разницу между простым объектом и списком. Объект — самостоятельный тип данных, из которого, как из конструктора, можно собрать абстрактные структуры данных. Например, связные списки. Давайте посмотрим на обычный объект, в котором нет ссылок на другие объекты. И сравним его со связным списком.
      
<pre><code>let adress = {
  street: 'Ленина',
  number: 56,
  city: 'Москва'
}

console.log(adress['street']); 
// Выведет 'Ленина'</code></pre>
      
В таком объекте мы легко можем получить значение любого элемента, достаточно знать ключ. А что со связным списком? Например, если с его помощью мы составили маршрут.

<pre><code>let route = {
  street: 'Итальянская',
  number: 20,
  next: {
    street: 'Тореза',
    number: 17,
    next: {
      street: 'Ленина',
      number: 56,
      next: {
        // и так далее
      }
    }
  }
}

console.log(route['next']['next']['street']);
// Выведет 'Ленина'</code></pre>

Мы не можем просто так узнать, какая улица будет третьей. Сначала надо добраться до того объекта, где записана эта улица и только потом получить её название. В общем-то это похоже на настоящий маршрут. Если бы мы шли пешком по маршруту, описанному в списке выше, мы бы не смогли сразу попасть на улицу Ленина, не пройдя по Итальянской и Тореза. Так и работают связные списки: чтобы добраться до какого-то из объектов, надо сначала перебрать все предыдущие, обходных путей нет.`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `И не зря!
      
Связный список состоит из объектов, поэтому значение мы, конечно, получим по ключу. Но так же быстро, как в обычном объекте, не получится.

Тут важно понять разницу между простым объектом и списком. Объект — самостоятельный тип данных, из которого, как из конструктора, можно собрать абстрактные структуры данных. Например, связные списки. Давайте посмотрим на обычный объект, в котором нет ссылок на другие объекты. И сравним его со связным списком.
      
<pre><code>let adress = {
  street: 'Ленина',
  number: 56,
  city: 'Москва'
}

console.log(adress['street']); 
// Выведет 'Ленина'</code></pre>
      
В таком объекте мы легко можем получить значение любого элемента, достаточно знать ключ. А что со связным списком? Например, если с его помощью мы составили маршрут.

<pre><code>let route = {
  street: 'Итальянская',
  number: 20,
  next: {
    street: 'Тореза',
    number: 17,
    next: {
      street: 'Ленина',
      number: 56,
      next: {
        // и так далее
      }
    }
  }
}

console.log(route['next']['next']['street']);
// Выведет 'Ленина'</code></pre>

Мы не можем просто так узнать, какая улица будет третьей. Сначала надо добраться до того объекта, где записана эта улица и только потом получить её название. В общем-то это похоже на настоящий маршрут. Если бы мы шли пешком по маршруту, описанному в списке выше, мы бы не смогли сразу попасть на улицу Ленина, не пройдя по Итальянской и Тореза. Так и работают связные списки: чтобы добраться до какого-то из объектов, надо сначала перебрать все предыдущие, обходных путей нет.`
      }
    }
  ],

  '10': [
    {
      isCorrect: true,
      content: {
        text: `Именно так. 

При работе со списками новое место в памяти выделяется по мере ввода новых элементов. А так как объекты умеют ссылаться друг на друга, как в связных списках, то новое место в памяти может быть, где угодно, элементам необязательно находиться в памяти рядом, ведь есть указатель на каждый элемент. Помните, наш связный список с рецептом из прошлого задания?`,
        image: './images/lists.png',
        anotherText: `С массивами всё иначе. Ещё до начала использования массива в памяти выделяется под него место. И если добавить в массив новых элементов, это место увеличится и массив может перестать помещаться, придётся искать ему новый слот в памяти. Конечно, можно заранее сделать большущий массив, тогда ничего двигать не придётся. Но если лишнее место не будет использовано, память будет расходоваться неэффективно. 

В <a href="https://pda.litres.ru/aditya-bhargava/grokaem-algoritmy-illustrirovannoe-posobie-dlya-p-39158380/?utm_source=google&utm_medium=cpc&utm_campaign=search_dsa_ohvat_f%7C2087774395&utm_term=&utm_content=433453034319%7Bphrase_id%7D_%7Bsource%7D_%7Bsource_type%7D_%7Bregion_name%7D_9051401&param_2=987239&gclid=EAIaIQobChMIrJ7Fi7Xw6wIVhPuyCh1aIgoeEAAYAyAAEgLki_D_BwE">книге «Грокаем алгоритмы»</a> приводится наглядный пример с кинотеатром. Представьте, что вы приходите в кино компанией друзей. Допустим, вас 7 человек. Вы хотите сесть все вместе, поэтому ищите 7 свободных мест рядышком. Кое-как места нашлись. Приходит ещё один ваш друг, а ещё одного свободного места рядом нет. И вам снова приходится искать места, чтобы вы все смогли сесть вместе. Примерно так выглядит выделение памяти для массива.

Представим теперь, что вы пришли той же компанией в кино. В зале нет 8 свободных мест рядом, поэтому вы рассаживаетесь, кто куда. При этом лично вам не надо запоминать кто где сидит. Вы можете запомнить, где сидит ваш друг Ваня, Ваня запомнит, где сидит Катя, и так далее. Так вы не потеряете друг друга и сможете посмотреть кино. Примерно так работает выделение памяти для связных списков.

Это не значит, что связные списки лучше массивов и стоит всегда использовать их. Всё зависит от задачи: для каждой у разных структур будут свои преимущества и недостатки. 
        
В следующих заданиях мы узнаем о ещё нескольких отличиях массивов и связных списков, а дальше потренируемся выбирать подходящую под задачу структуру данных.`,
        anotherImage: './images/arrays.png'
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Нет. Ещё до начала использования массива в памяти выделяется под него место. И если добавить в массив новых элементов, это место увеличится и массив может перестать помещаться, придётся искать ему новый слот в памяти. Конечно, можно заранее сделать большущий массив, тогда ничего двигать не придётся. Но если лишнее место не будет использовано, память будет расходоваться неэффективно.`,
        image: './images/arrays.png',
        anotherText: `А вот при работе со списками новое место в памяти выделяется по мере ввода новых элементов. А так как объекты могут ссылаться друг на друга, как в связных списках, то новое место в памяти может быть, где угодно, элементам необязательно находиться в памяти рядом, ведь есть указатель на каждый элемент. Помните, наш список с рецептом из прошлого задания?
        
В <a href="https://pda.litres.ru/aditya-bhargava/grokaem-algoritmy-illustrirovannoe-posobie-dlya-p-39158380/?utm_source=google&utm_medium=cpc&utm_campaign=search_dsa_ohvat_f%7C2087774395&utm_term=&utm_content=433453034319%7Bphrase_id%7D_%7Bsource%7D_%7Bsource_type%7D_%7Bregion_name%7D_9051401&param_2=987239&gclid=EAIaIQobChMIrJ7Fi7Xw6wIVhPuyCh1aIgoeEAAYAyAAEgLki_D_BwE">книге «Грокаем алгоритмы»</a> приводится наглядный пример с кинотеатром. Представьте, что вы приходите в кино компанией друзей. Допустим, вас 7 человек. Вы хотите сесть все вместе, поэтому ищите 7 свободных мест рядышком. Кое-как места нашлись. Приходит ещё один ваш друг, а ещё одного свободного места рядом нет. И вам снова приходится искать места, чтобы вы все смогли сесть вместе. Примерно так выглядит выделение памяти для массива.

Представим теперь, что вы пришли той же компанией в кино. В зале нет 8 свободных мест рядом, поэтому вы рассаживаетесь, кто куда. При этом лично вам не надо запоминать кто где сидит. Вы можете запомнить, где сидит ваш друг Ваня, Ваня запомнит, где сидит Катя, и так далее. Так вы не потеряете друг друга и сможете посмотреть кино. Примерно так работает выделение памяти для связных списков.
        
Это не значит, что связные списки лучше массивов и стоит всегда использовать их. Всё зависит от задачи: для каждой у разных структур будут свои преимущества и недостатки. 
        
В следующих заданиях мы узнаем о ещё нескольких отличиях массивов и связных списков, а дальше потренируемся выбирать подходящую под задачу структуру данных.`,
        anotherImage: './images/lists.png'
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Нет, разница есть.

При работе со списками новое место в памяти выделяется по мере ввода новых элементов. А так как объекты могут ссылаться друг на друга, как в связных списках, то новое место в памяти может быть, где угодно, элементам необязательно находиться в памяти рядом, ведь есть указатель на каждый элемент. Помните наш список с рецептом из прошлого задания?`,
        image: './images/lists.png',
        anotherText: `С массивами всё иначе. Ещё до начала использования массива в памяти выделяется под него место. И если добавить в массив новых элементов, это место увеличится и массив может перестать помещаться, придётся искать ему новый слот в памяти. Конечно, можно заранее сделать большущий массив, тогда ничего двигать не придётся. Но если лишнее место не будет использовано, память будет расходоваться неэффективно.

В <a href="https://pda.litres.ru/aditya-bhargava/grokaem-algoritmy-illustrirovannoe-posobie-dlya-p-39158380/?utm_source=google&utm_medium=cpc&utm_campaign=search_dsa_ohvat_f%7C2087774395&utm_term=&utm_content=433453034319%7Bphrase_id%7D_%7Bsource%7D_%7Bsource_type%7D_%7Bregion_name%7D_9051401&param_2=987239&gclid=EAIaIQobChMIrJ7Fi7Xw6wIVhPuyCh1aIgoeEAAYAyAAEgLki_D_BwE">книге «Грокаем алгоритмы»</a> приводится наглядный пример с кинотеатром. Представьте, что вы приходите в кино компанией друзей. Допустим, вас 7 человек. Вы хотите сесть все вместе, поэтому ищите 7 свободных мест рядышком. Кое-как места нашлись. Приходит ещё один ваш друг, а ещё одного свободного места рядом нет. И вам снова приходится искать места, чтобы вы все смогли сесть вместе. Примерно так выглядит выделение памяти для массива.

Представим теперь, что вы пришли той же компанией в кино. В зале нет 8 свободных мест рядом, поэтому вы рассаживаетесь, кто куда. При этом лично вам не надо запоминать кто где сидит. Вы можете запомнить, где сидит ваш друг Ваня, Ваня запомнит, где сидит Катя, и так далее. Так вы не потеряете друг друга и сможете посмотреть кино. Примерно так работает выделение памяти для связных списков.
        
Это не значит, что связные списки лучше массивов и стоит всегда использовать их. Всё зависит от задачи: для каждой у разных структур будут свои преимущества и недостатки. 
        
В следующих заданиях мы узнаем о ещё нескольких отличиях массивов и связных списков, а дальше потренируемся выбирать подходящую под задачу структуру данных.`,
        anotherImage: './images/arrays.png'
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Нестрашно!

При работе со списками новое место в памяти выделяется по мере ввода новых элементов. А так как объекты могут ссылаться друг на друга, как в связных списках, то новое место в памяти может быть, где угодно, элементам необязательно находиться в памяти рядом, ведь есть указатель на каждый элемент.`,
        image: './images/lists.png',
        anotherText: `С массивами всё иначе. Ещё до начала использования массива в памяти выделяется под него место. И если добавить в массив новых элементов, это место увеличится и массив может перестать помещаться, придётся искать ему новый слот в памяти. Конечно, можно заранее сделать большущий массив, тогда ничего двигать не придётся. Но если лишнее место не будет использовано, память будет расходоваться неэффективно.
        
В <a href="https://pda.litres.ru/aditya-bhargava/grokaem-algoritmy-illustrirovannoe-posobie-dlya-p-39158380/?utm_source=google&utm_medium=cpc&utm_campaign=search_dsa_ohvat_f%7C2087774395&utm_term=&utm_content=433453034319%7Bphrase_id%7D_%7Bsource%7D_%7Bsource_type%7D_%7Bregion_name%7D_9051401&param_2=987239&gclid=EAIaIQobChMIrJ7Fi7Xw6wIVhPuyCh1aIgoeEAAYAyAAEgLki_D_BwE">книге «Грокаем алгоритмы»</a> приводится наглядный пример с кинотеатром. Представьте, что вы приходите в кино компанией друзей. Допустим, вас 7 человек. Вы хотите сесть все вместе, поэтому ищите 7 свободных мест рядышком. Кое-как места нашлись. Приходит ещё один ваш друг, а ещё одного свободного места рядом нет. И вам снова приходится искать места, чтобы вы все смогли сесть вместе. Примерно так выглядит выделение памяти для массива.

Представим теперь, что вы пришли той же компанией в кино. В зале нет 8 свободных мест рядом, поэтому вы рассаживаетесь, кто куда. При этом лично вам не надо запоминать кто где сидит. Вы можете запомнить, где сидит ваш друг Ваня, Ваня запомнит, где сидит Катя, и так далее. Так вы не потеряете друг друга и сможете посмотреть кино. Примерно так работает выделение памяти для связных списков.
        
Это не значит, что связные списки лучше массивов и стоит всегда использовать их. Всё зависит от задачи: для каждой у разных структур будут свои преимущества и недостатки. 
        
В следующих заданиях мы узнаем о ещё нескольких отличиях массивов и связных списков, а дальше потренируемся выбирать подходящую под задачу структуру данных.`,
        anotherImage: './images/arrays.png',
      }
    }
  ],

  '11': [
    {
      isCorrect: false,
      content: {
        text: `Нет. Вставка нового элемента в массив дороже, чем вставка в список. Помните, в списках каждый элемент хранит ссылку на следующий? Да и в памяти элементы могут лежать кто где. Чтобы добавить новый элемент в список, достаточно в одном месте добавить ссылку на него.
        
<pre><code>let salt = {
  name: 'добавить щепотку соли',
  next: null
}

let recipe = {
  name: 'взять глубокую миску',
  next: {
    name: 'взять два яйца',
    next: {
      name: 'разбить два яйца в миску',
      next: {
        name: 'взять 500 мл молока',
        next: {
          name: 'налить молоко в миску к яйцам',
          next: {
           // и так далее
          }
        }
      }
    }
  }

// Добавим ссылку на объект с солью в список
// И зададим следующий элемент объекту с солью,
// чтобы список продолжился

let salt = {
  name: 'добавить щепотку соли',
  next: {
    name: 'налить молоко в миску к яйцам',
    next: {
      // и так далее
    }
  }
}

let recipe = {
  name: 'взять глубокую миску',
  next: {
    name: 'взять два яйца',
    next: {
      name: 'разбить два яйца в миску',
      next: {
        name: 'взять 500 мл молока',
        next: salt
      }
    }
  }
}</code></pre>

В память добавилась ссылка на ещё один объект.

А что если добавить новый элемент в массив? Тогда в массиве произойдёт перемещение всех элементов и пересчёт индексов. Представляете, если мы добавим новый элемент в начало массива? Он станет нулевым. Тот, что был нулевым, должен будет стать первым. Первый станет вторым. И так далее. А если массив был большой, на сотни элементов?

С удалением всё точно так же. В списке мы просто убираем ссылку на объект и всё. А в массиве удалённый элемент надо убрать, передвинуть все элементы (кто-то ведь должен занять пустующее место), пересчитать все индексы. Поэтому добавление и удаление элементов в списках проще с точки зрения памяти. Это происходит быстро, без большого количества операций.`
      }
    },
    {
      isCorrect: true,
      content: {
        text: `Да! Вставка нового элемента в массив дороже, чем вставка в список. Помните, в списках каждый элемент хранит ссылку на следующий? Да и в памяти элементы могут лежать кто где. Чтобы добавить новый элемент в список, достаточно в одном месте добавить ссылку на него.

<pre><code>let salt = {
  name: 'добавить щепотку соли',
  next: null
}

let recipe = {
  name: 'взять глубокую миску',
  next: {
    name: 'взять два яйца',
    next: {
      name: 'разбить два яйца в миску',
      next: {
        name: 'взять 500 мл молока',
        next: {
          name: 'налить молоко в миску к яйцам',
          next: {
            // и так далее
          }
        }
      }
    }
  }

// Добавим ссылку на объект с солью в список
// И зададим следующий элемент объекту с солью,
// чтобы список продолжился

let salt = {
  name: 'добавить щепотку соли',
  next: {
    name: 'налить молоко в миску к яйцам',
    next: {
      // и так далее
    }
  }
}

let recipe = {
  name: 'взять глубокую миску',
  next: {
    name: 'взять два яйца',
    next: {
      name: 'разбить два яйца в миску',
      next: {
        name: 'взять 500 мл молока',
        next: salt
      }
    }
  }
}</code></pre>

В память добавилась ссылка ещё на один объект.

А что если добавить новый элемент в массив? Тогда в массиве произойдёт перемещение всех элементов и пересчёт индексов. Представляете, если мы добавим новый элемент в начало массива? Он станет нулевым. Тот, что был нулевым, должен будет стать первым. Первый станет вторым. И так далее. А если массив был большой, на сотни элементов?

С удалением всё точно так же. В списке мы просто убираем ссылку на объект и всё. А в массиве удалённый элемент надо убрать, передвинуть все элементы (кто-то ведь должен занять пустующее место), пересчитать все индексы. Поэтому добавление и удаление элементов в списках проще с точки зрения памяти. Это происходит быстро, без большого количества операций.`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Нет. Вставка нового элемента в массив дороже, чем вставка в список. Помните, в списках каждый элемент хранит ссылку на следующий? Да и в памяти элементы могут лежать кто где. Чтобы добавить новый элемент в список, достаточно в одном месте добавить ссылку на него.
        
<pre><code>let salt = {
  name: 'добавить щепотку соли',
  next: null
}

let recipe = {
  name: 'взять глубокую миску',
  next: {
    name: 'взять два яйца',
    next: {
      name: 'разбить два яйца в миску',
      next: {
        name: 'взять 500 мл молока',
        next: {
          name: 'налить молоко в миску к яйцам',
          next: {
            // и так далее
          }
        }
      }
    }
  }

// Добавим ссылку на объект с солью в список
// И зададим следующий элемент объекту с солью,
// чтобы список продолжился

let salt = {
  name: 'добавить щепотку соли',
  next: {
    name: 'налить молоко в миску к яйцам',
    next: {
      // и так далее
    }
  }
}

let recipe = {
  name: 'взять глубокую миску',
  next: {
    name: 'взять два яйца',
    next: {
      name: 'разбить два яйца в миску',
      next: {
        name: 'взять 500 мл молока',
        next: salt
      }
    }
  }
}</code></pre>

В память добавилась ссылка ещё на один объект.

А что если добавить новый элемент в массив? Тогда в массиве произойдёт перемещение всех элементов и пересчёт индексов. Представляете, если мы добавим новый элемент в начало массива? Он станет нулевым. Тот, что был нулевым, должен будет стать первым. Первый станет вторым. И так далее. А если массив был большой, на сотни элементов?

С удалением всё точно так же. В списке мы просто убираем ссылку на объект и всё. А в массиве удалённый элемент надо убрать, передвинуть все элементы (кто-то ведь должен занять пустующее место), пересчитать все индексы. Поэтому добавление и удаление элементов в списках проще с точки зрения памяти. Это происходит быстро, без большого количества операций.`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Ничего!

Вставка нового элемента в массив дороже, чем вставка в список. Помните, в списках каждый элемент хранит ссылку на следующий? Да и в памяти элементы могут лежать кто где. Чтобы добавить новый элемент в список, достаточно в одном месте добавить ссылку на него.

<pre><code>let salt = {
  name: 'добавить щепотку соли',
  next: null
}

let recipe = {
  name: 'взять глубокую миску',
  next: {
    name: 'взять два яйца',
    next: {
      name: 'разбить два яйца в миску',
      next: {
        name: 'взять 500 мл молока',
        next: {
          name: 'налить молоко в миску к яйцам',
          next: {
            // и так далее
          }
        }
      }
    }
  }

// Добавим ссылку на объект с солью в список
// И зададим следующий элемент объекту с солью,
// чтобы список продолжился

let salt = {
  name: 'добавить щепотку соли',
  next: {
    name: 'налить молоко в миску к яйцам',
    next: {
      // и так далее
    }
  }
}

let recipe = {
  name: 'взять глубокую миску',
  next: {
    name: 'взять два яйца',
    next: {
      name: 'разбить два яйца в миску',
      next: {
        name: 'взять 500 мл молока',
        next: salt
      }
    }
  }
}</code></pre>

В память добавилась ссылка ещё на один объект.

А что если добавить новый элемент в массив? Тогда в массиве произойдёт перемещение всех элементов и пересчёт индексов. Представляете, если мы добавим новый элемент в начало массива? Он станет нулевым. Тот, что был нулевым, должен будет стать первым. Первый станет вторым. И так далее. А если массив был большой, на сотни элементов?

С удалением всё точно так же. В списке мы просто убираем ссылку на объект и всё. А в массиве удалённый элемент надо убрать, передвинуть все элементы (кто-то ведь должен занять пустующее место), пересчитать все индексы. Поэтому добавление и удаление элементов в списках проще с точки зрения памяти. Это происходит быстро, без большого количества операций.`
      }
    }
  ],

  '12': [
    {
      isCorrect: true,
      content: {
        text: `Может быть.

У массивов есть встроенные методы добавления элементов. Да, добавление элементов в массив дороже, чем добавление в список, зато не придётся придумывать свой собственный метод для добавления заказов в конец, как если бы мы работали со списками. Правда больше никаких преимуществ массивов мы использовать не будем. Нам достаточно будет идти по заказам последовательно, перебором, и не забывать добавлять новые заказы в конец.
        
Для этой задачи можно использовать и списки. Мы часто будем добавлять в список новые элементы — заказы, а списки умеют делать это быстрее, чем массивы. Каждый новый заказ будет добавляться в конец списка, поэтому мы сможем последовательно идти по списку, с первого элемента к последнему, и получать данные по заказам. Произвольный доступ к элементу, как в массиве, нам не пригодится. Правда, придётся написать немного кода, чтобы каждый новый заказ добавлялся в конец списка. Но это ведь не проблема, правда?
        
В программировании нет правильных ответов. Решить задачу можно разными способами. А принятие решения — ответственность разработчика.`
      }
    },
    {
      isCorrect: true,
      content: {
        text: `Да, он подойдёт.

Мы часто будем добавлять в список новые элементы — заказы, а списки умеют быстро это делать. Каждый новый заказ будет добавляться в конец списка, поэтому мы сможем последовательно идти по списку с первого элемента к последнему и получать данные по заказам. Произвольный доступ к элементу, как в массиве, нам не пригодится. Правда, придётся написать немного кода, чтобы каждый новый заказ добавлялся в конец списка. Но это ведь не проблема, правда?
        
На самом деле для этой задачи можно использовать и массивы. У них есть встроенные методы добавления элементов. Да, добавление элементов в массив дороже, чем добавление в список, зато не придётся придумывать свой собственный метод для добавления заказов в конец. В программировании нет правильных ответов. Решить задачу можно разными способами. А принятие решения — ответственность разработчика.`
      }
    },
    {
      isCorrect: true,
      content: {
        text: `Да, но каждый по-своему.

У массивов есть встроенные методы добавления элементов. Да, добавление элементов в массив дороже, чем добавление в список, зато не придётся придумывать свой собственный метод для добавления заказов в конец, как если бы мы работали со списками. Правда больше никаких преимуществ массивов мы использовать не будем. Нам достаточно будет идти по заказам последовательно, перебором, и не забывать добавлять новые заказы в конец.
        
Для этой задачи можно использовать и списки. Мы часто будем добавлять в список новые элементы — заказы, а списки умеют делать это быстрее, чем массивы. Каждый новый заказ будет добавляться в конец списка, поэтому мы сможем последовательно идти по списку, с первого элемента к последнему, и получать данные по заказам. Произвольный доступ к элементу, как в массиве, нам не пригодится. Правда, придётся написать немного кода, чтобы каждый новый заказ добавлялся в конец списка. Но это ведь не проблема, правда?
        
В программировании нет правильных ответов. Решить задачу можно разными способами. А принятие решения — ответственность разработчика.`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Давайте разбираться.

Начнём с массивов. У массивов есть встроенные методы добавления элементов. Да, добавление элементов в массив дороже, чем добавление в список, зато не придётся придумывать свой собственный метод для добавления заказов в конец, как если бы мы работали со списками. Правда больше никаких преимуществ массивов мы использовать не будем. Нам достаточно будет идти по заказам последовательно, перебором, и не забывать добавлять новые заказы в конец.
        
Для этой задачи можно использовать и списки. Мы часто будем добавлять в список новые элементы — заказы, а списки умеют делать это быстрее, чем массивы. Каждый новый заказ будет добавляться в конец списка, поэтому мы сможем последовательно идти по списку, с первого элемента к последнему, и получать данные по заказам. Произвольный доступ к элементу, как в массиве, нам не пригодится. Правда, придётся написать немного кода, чтобы каждый новый заказ добавлялся в конец списка. Но это ведь не проблема, правда?
        
В программировании нет правильных ответов. Решить задачу можно разными способами. А принятие решения — ответственность разработчика.`
      }
    }
  ],

  '13': [
    {
      isCorrect: false,
      content: {
        text: `Не. В данном случае у нас упорядоченный список песен, он расположен по нарастающей сложности. Пользователь может выбрать любую песню, список такой возможности не даёт: нельзя выбрать третью песню, не пройдя через первую и вторую. А в массиве можно легко получить доступ к любому элементу по индексу. Добавлять и удалять элементы мы не планируем, а значит получится использовать только сильные стороны массива.`
      }
    },
    {
      isCorrect: true,
      content: {
        text: `Именно! В данном случае у нас упорядоченный список песен, он расположен по нарастающей сложности. Пользователь может выбрать любую песню, список такой возможности не даёт: нельзя выбрать третью песню, не пройдя через первую и вторую. А в массиве можно легко получить доступ к любому элементу по индексу. Добавлять и удалять элементы мы не планируем, а значит получится использовать только сильные стороны массива.`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Оба и правда норм, но для решения задачи лучше подойдёт массив. 

В данном случае у нас упорядоченный список песен, он расположен по нарастающей сложности. Пользователь может выбрать любую песню, список такой возможности не даёт: нельзя выбрать третью песню, не пройдя через первую и вторую. А в массиве можно легко получить доступ к любому элементу по индексу. Добавлять и удалять элементы мы не планируем, а значит получится использовать только сильные стороны массива.`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Подойдёт массив. В данном случае у нас упорядоченный список песен, он расположен по нарастающей сложности. Пользователь может выбрать любую песню, список такой возможности не даёт: нельзя выбрать третью песню, не пройдя через первую и вторую. А в массиве можно легко получить доступ к любому элементу по индексу. Добавлять и удалять элементы мы не планируем, а значит получится использовать только сильные стороны массива.`
      }
    }
  ],

  '14': [
    {
      isCorrect: true,
      content: {
        text: `Да, годится. Нам не нужно внезапно получать ноту из середины мелодии, добавлять и удалять элементы, мы просто пойдём по порядку, нота за нотой. Поэтому список с указанием на следующую ноту подойдёт. Достаточно будет написать простенький итератор с условием типа 
<code>while (current. next) { // код итератора }</code> и ноты будут проигрываться.

Но нельзя сказать, что массив для такой задачи не годится. Можно точно так же записать ноты в массив и с помощью итератора его перебрать. Да, придётся завести счётчик, условие выхода из цикла, но это примерно столько же кода, сколько и в итераторе для списка. 
        
Поэтому тут нет единственного верного ответа, многое зависит от дополнительных фич. Решение за разработчиком.`
      }
    },
    {
      isCorrect: true,
      content: {
        text: `Да, годится. Можно записать ноты по порядку в массив и перебрать его с помощью итератора. Вставлять и удалять элементы мы не будем и даже получать доступ к какой-нибудь ноте из середины массива нам не понадобится.

Но нельзя сказать, что здесь не подойдёт связный список. Нам нужно идти по порядку, нота за нотой. Поэтому список с указанием на следующую ноту подойдёт. Достаточно будет написать простенький итератор с условием типа 
<code>while (current. next) { // код итератора }</code> 
и ноты будут проигрываться.
        
Поэтому тут нет единственного верного ответа, многое зависит от дополнительных фич. Решение за разработчиком.`
      }
    },
    {
      isCorrect: true,
      content: {
        text: `Да, вы правы. 

Можно записать ноты по порядку в массив и перебрать его с помощью итератора. Вставлять и удалять элементы мы не будем и даже получать доступ к какой-нибудь ноте из середины массива нам не понадобится.
        
Но нельзя сказать, что здесь не подойдёт связный список. Нам нужно идти по порядку, нота за нотой. Поэтому список с указанием на следующую ноту подойдёт. Достаточно будет написать простенький итератор с условием типа 
<code>while (current. next) { // код итератора }</code> 
и ноты будут проигрываться.
        
Поэтому тут нет единственного верного ответа, многое зависит от дополнительных фич. Решение за разработчиком.`
      }
    },
    {
      isCorrect: false,
      content: {
        text: `Нам не нужно внезапно получать ноту из середины мелодии, добавлять и удалять элементы, мы просто пойдём по порядку, нота за нотой. Поэтому список с указанием на следующую ноту подойдёт. Достаточно будет написать простенький итератор с условием типа 
<code>while (current. next) { // код итератора }</code> 
и ноты будут проигрываться.
        
Но нельзя сказать, что массив для такой задачи не годится. Можно точно так же записать ноты в массив и с помощью итератора его перебрать. Да, придётся завести счётчик, условие выхода из цикла, но это примерно столько же кода, сколько и в итераторе для списка. 
        
Поэтому тут нет единственного верного ответа, многое зависит от дополнительных фич. Решение за разработчиком.`
      }
    }
  ]
};

const getAnswer = (day: string, answerId: string | undefined = '') => answers[day][answerId];

export default {
  id: 'dataStructures',
  order: 60,
  name: 'Структуры данных',
  active: true,
  description: () => {
    return [
      '<b>Cтруктуры данных</b>',
      '',
      'В этом курсе вы познакомитесь со структурами данных.',
      'Узнаете, какие бывают структуры, для чего используются, научитесь базовым операциям с ними.',
      'Познакомитесь со стеком, очередью и связными списками. Узнаете про разницу между массивами и списками, потренируетесь выбирать подходящую структуру данных под задачу.',
      'Если вы совсем новичок, вам как раз сюда!',
      '',
      'Курс сделан в формате теста и идёт две недели — каждый день будет приходить новый вопрос. Вам нужно выбрать вариант ответа. Нестрашно, если ошибётесь. В любом случае вы получите подробное объяснение и узнаете правильный ответ.',
      '',
      'Для <a href="https://www.patreon.com/winterview?dataStructures">патронов даже на $1 тирах</a> доступен весь курс. Остальным будут доступны задания первых трёх дней.',
    ].join('\n');
  },
  state: {
    day: 1,
    answers: []
  },
  initial: 'day1',
  blocks: {
    end: {
      final: true,
      wait: true,
      execute: async ({ state, send }) => {
        await send({
          message: [
            getTaskHeader(-1),
            getFinalText(state.answers, 14)
          ].join('\n')
        });
      }
    },
    day1: {
      execute: async ({transition, send}) => {
        await send({
          message: [
            '<b>Cтруктуры данных</b>',
            '',
            'Для начала давайте выясним, что вообще такое эти <b>структуры данных</b>?',
            '',
            'По сути это разные способы хранить информацию. И этих способов много. У каждой структуры есть свои особенности — она может быть эффективна в одних случаях и не очень эффективна в других. Задача разработчика — выбрать наиболее подходящую структуру данных для задачи.',
            '',
            'Обычно этим занимаются не начинающие разработчики, а ребята с уровнем middle и senior. Но на собеседованиях про структуры данных часто спрашивают и junior-разработчиков. А понимание того, как эффективно можно хранить данные, даст вам +100 очков к карьерному развитию.',
            '',
            'Ниже вас уже ждёт первый вопрос по структурам данных. Удачи!',
            '',
            '',
            '<i>Если у вас возникнут вопросы и пожелания по курсу, можете писать автору — @greenlera. Лера — продюсер и автор курсов по веб-разработке.</i>'
          ].join('\n'),
        });

        await send({
          message: [
            getTaskHeader(1),
            'Вы находитесь на какой-то странице, это последняя страница в истории вашего браузера. После нажатия на кнопку «назад», браузер переходит на предыдущую посещённую страницу. Какую структуру данных лучше всего использовать для хранения такой истории браузера?'
          ].join('\n'),
          buttons: [
            [
              {
                text: 'Стек',
                action: 'checkAnswer',
                argument: '1/0'
              },
              {
                text: 'Очередь',
                action: 'checkAnswer',
                argument: '1/1'
              }
            ],
            [
              {
                text: 'Дерево',
                action: 'checkAnswer',
                argument: '1/2'
              },
              {
                text: 'Не знаю',
                action: 'checkAnswer',
                argument: '1/3'
              }
            ]
          ]
        });
        await transition('day2');
      },
    },
    day2: {
      wait: true,
      execute: async ({transition, send}) => {
        await send({
          message: [
            getTaskHeader(2),
            'В JavaScript нет специальной структуры для стеков, как в Java, C+ и C#. Поэтому для реализации стека можно использовать массивы. Какой метод подойдёт для записи новых элементов?',
          ].join('\n'),
          buttons: [
            [
              {
                text: 'pop',
                action: 'checkAnswer',
                argument: '2/0'
              },
              {
                text: 'push',
                action: 'checkAnswer',
                argument: '2/1'
              }
            ],
            [
              {
                text: 'unshift',
                action: 'checkAnswer',
                argument: '2/2'
              },
              {
                text: 'Не знаю',
                action: 'checkAnswer',
                argument: '2/3'
              }
            ]
          ]
        });
        await transition('day3');
      },
    },
    day3: {
      wait: true,
      execute: async ({transition, send}) => {
        await send({
          message: [
            getTaskHeader(3),
            'Какой метод массива подойдёт для получения последних добавленных элементов, если мы используем массив, как стек?',
          ].join('\n'),
          buttons: [
            [
              {
                text:'pop',
                action: 'checkAnswer',
                argument: '3/0'
              },
              {
                text: 'push',
                action: 'checkAnswer',
                argument: '3/1'
              }
            ],
            [
              {
                text: 'shift',
                action: 'checkAnswer',
                argument: '3/2'
              },
              {
                text: 'Не знаю',
                action: 'checkAnswer',
                argument: '3/3'
              }
            ]
          ]
        });
        await transition('day4');
      },
    },
    day4: {
      wait: true,
      paywall: true,
      execute: async ({transition, send}) => {
        await send({
          message: [
            getTaskHeader(4),
            `Какое слово пропущено в тексте?

____ вызовов — механизм, который помогает интерпретатору отслеживать текущее выполнение кода и хранить контексты выполнения всех функций из скрипта.`,
          ].join('\n'),
          buttons: [
            [
              {
                text: 'Очередь',
                action: 'checkAnswer',
                argument: '4/0'
              },
              {
                text: 'Стек',
                action: 'checkAnswer',
                argument: '4/1'
              }
            ],
            [
              {
                text: 'Переадресация',
                action: 'checkAnswer',
                argument: '4/2'
              },
              {
                text: 'Не знаю',
                action: 'checkAnswer',
                argument: '4/3'
              }
            ]
          ]
        });
        await transition('day5');
      },
    },
    day5: {
      wait: true,
      execute: async ({transition, send}) => {
        await send({
          message: [
            getTaskHeader(5),
            'Представьте, что вы пишите приложение для интерактивного обучения игре на синтезаторе. Пользователь может выбрать мелодию и посмотреть, как она играется, нота за нотой, нужные клавиши будут подсвечиваться на экране. Какую структуру данных вы выберете для хранения нот?',
          ].join('\n'),
          buttons: [
            [
              {
                text: 'Стек',
                action: 'checkAnswer',
                argument: '5/0'
              },
              {
                text: 'Не знаю',
                action: 'checkAnswer',
                argument: '5/1'
              }
            ],
            [
              {
                text: 'Хеш-таблица',
                action: 'checkAnswer',
                argument: '5/2'
              },
              {
                text: 'Очередь',
                action: 'checkAnswer',
                argument: '5/3'
              }
            ]
          ]
        });
        await transition('day6');
      },
    },
    day6: {
      wait: true,
      execute: async ({transition, send}) => {
        await send({
          message: [
            getTaskHeader(6),
            'Как и со стеками, в JavaScript нет специальной структуры для очередей. Для их реализации можно использовать массивы. Какой метод подойдёт для записи новых элементов?',
          ].join('\n'),
          buttons: [
            [
              {
                text: 'pop',
                action: 'checkAnswer',
                argument: '6/0'
              },
              {
                text: 'unshift',
                action: 'checkAnswer',
                argument: '6/1'
              }
            ],
            [
              {
                text: 'push',
                action: 'checkAnswer',
                argument: '6/2'
              },
              {
                text: 'Не знаю',
                action: 'checkAnswer',
                argument: '6/3'
              }
            ]
          ]
        });
        await transition('day7');
      },
    },
    day7: {
      wait: true,
      execute: async ({transition, setState, send}) => {
        await send({
          message: [
            getTaskHeader(7),
            'Какой метод подойдёт для получения старых добавленных элементов, если мы используем массив, как очередь?',
          ].join('\n'),
          buttons: [
            [
              {
                text: 'pop',
                action: 'checkAnswer',
                argument: '7/0'
              },
              {
                text: 'push',
                action: 'checkAnswer',
                argument: '7/1'
              }
            ],
            [
              {
                text: 'shift',
                action: 'checkAnswer',
                argument: '7/2'
              },
              {
                text: 'Не знаю',
                action: 'checkAnswer',
                argument: '7/3'
              }
            ]
          ]
        });
        await transition('day8');
      },
    },
    day8: {
      wait: true,
      execute: async ({transition, setState, send}) => {
        await send({
          message: [
            getTaskHeader(8),
            'Пришло время познакомиться с ещё одной структурой данных. Она используется часто, как и стеки с очередями, а может и чаще. Каждый элемент этой структуры содержит информацию о себе и ссылку на следующий элемент этой же структуры. Как думаете, как называется такая структура данных?',
          ].join('\n'),
          buttons: [
            [
              {
                text: 'Объект с объектами',
                action: 'checkAnswer',
                argument: '8/0'
              },
              {
                text: 'Связный список',
                action: 'checkAnswer',
                argument: '8/1'
              }
            ],
            [
              {
                text: 'Просто список',
                action: 'checkAnswer',
                argument: '8/2'
              },
              {
                text: 'Не знаю',
                action: 'checkAnswer',
                argument: '8/3'
              }
            ]
          ]
        });
        await transition('day9');
      },
    },
    day9: {
      wait: true,
      execute: async ({transition, setState, send}) => {
        await send({
          message: [
            getTaskHeader(9),
            'В массиве можно моментально получить значение любого элемента по индексу, в объекте это можно сделать по ключу. А в связном списке так тоже можно?',
          ].join('\n'),
          buttons: [
            [
              {
                text: 'Да',
                action: 'checkAnswer',
                argument: '9/0'
              },
              {
                text: 'Да, но не так быстро',
                action: 'checkAnswer',
                argument: '9/1'
              }
            ],
            [
              {
                text: 'Нет',
                action: 'checkAnswer',
                argument: '9/2'
              },
              {
                text: 'Чую подхвох',
                action: 'checkAnswer',
                argument: '9/3'
              }
            ]
          ]
        });
        await transition('day10');
      },
    },
    day10: {
      wait: true,
      execute: async ({transition, setState, send}) => {
        await send({
          message: [
            getTaskHeader(10),
            `Теперь мы знаем, что структуры данных в JS можно реализовать с помощью массивов (стеки и очереди), познакомились со связными списками. А как понять, когда что использовать? Для этого надо знать отличия.

Как вы думаете, когда памяти выделяется меньше — при создании связного списка или массива?`,
          ].join('\n'),
          buttons: [
            [
              {
                text: 'Списка',
                action: 'checkAnswer',
                argument: '10/0'
              },
              {
                text: 'Массива',
                action: 'checkAnswer',
                argument: '10/1'
              }
            ],
            [
              {
                text: 'Одинаково',
                action: 'checkAnswer',
                argument: '10/2'
              },
              {
                text: 'Не знаю',
                action: 'checkAnswer',
                argument: '10/3'
              }
            ]
          ]
        });
        await transition('day11');
      },
    },
    day11: {
      wait: true,
      execute: async ({transition, setState, send}) => {
        await send({
          message: [
            getTaskHeader(11),
            'А что работает оптимальней при добавлении и удалении новых элементов: массив или связный список?',
          ].join('\n'),
          buttons: [
            [
              {
                text: 'Массив',
                action: 'checkAnswer',
                argument: '11/0'
              },
              {
                text: 'Список',
                action: 'checkAnswer',
                argument: '11/1'
              }
            ],
            [
              {
                text: 'Одинаково',
                action: 'checkAnswer',
                argument: '11/2'
              },
              {
                text: 'Не знаю',
                action: 'checkAnswer',
                argument: '11/3'
              }
            ]
          ]
        });
        await transition('day12');
      },
    },
    day12: {
      wait: true,
      execute: async ({transition, setState, send}) => {
        await send({
          message: [
            getTaskHeader(12),
            `Давайте подытожим полученные знания, а затем потренируемся выбирать структуры данных для разных задач.

Объекты и массивы, как кубики конструктора — из них можно собирать разные абстрактные структуры данных: очереди, стеки, связные списки <i>и много чего ещё</i>.
            
Массивы — быстрое чтение, медленная вставка и удаление элементов.
            
Списки — медленное чтение, быстрая вставка и удаление элементов.
            
Теперь потренируемся! 
            
Вы пишите приложение для ресторана. Официант принимает заказ через приложение, заказ добавляется в конец очереди, повар берёт первый заказ из очереди и начинает готовить. Что подойдёт больше для реализации приложения — массив или связный список?`,
          ].join('\n'),
          buttons: [
            [
              {
                text: 'Массив',
                action: 'checkAnswer',
                argument: '12/0'
              },
              {
                text: 'Связный список',
                action: 'checkAnswer',
                argument: '12/1'
              }
            ],
            [
              {
                text: 'Оба норм',
                action: 'checkAnswer',
                argument: '12/2'
              },
              {
                text: 'Не знаю',
                action: 'checkAnswer',
                argument: '12/3'
              }
            ]
          ]
        });
        await transition('day13');
      },
    }, 
    day13: {
      wait: true,
      execute: async ({transition, setState, send}) => {
        await send({
          message: [
            getTaskHeader(13),
            'Представим, что вы пишите музыкальное приложение. Пользователь видит список песен, расположенный по сложности исполнения. Можно выбрать любую из песен, а приложение поможет сыграть её по нотам. В какой структуре вы бы хранили песни для такого приложения?',
          ].join('\n'),
          buttons: [
            [
              {
                text: 'Связный список',
                action: 'checkAnswer',
                argument: '13/0'
              },
              {
                text: 'Массив',
                action: 'checkAnswer',
                argument: '13/1'
              }
            ],
            [
              {
                text: 'Оба норм',
                action: 'checkAnswer',
                argument: '13/2'
              },
              {
                text: 'Не знаю',
                action: 'checkAnswer',
                argument: '13/3'
              }
            ]
          ]
        });
        await transition('day14');
      },
    },
    day14: {
      wait: true,
      execute: async ({transition, setState, send}) => {
        await send({
          message: [
            getTaskHeader(14),
            'Пользователь выбрал мелодию. Приложение будет показывать, как её играть по нотам. В какой структуре вы бы хранили ноты песни?',
          ].join('\n'),
          buttons: [
            [
              {
                text: 'Связный список',
                action: 'checkAnswer',
                argument: '14/0'
              },
              {
                text: 'Массив',
                action: 'checkAnswer',
                argument: '14/1'
              }
            ],
            [
              {
                text: 'Оба норм',
                action: 'checkAnswer',
                argument: '14/2'
              },
              {
                text: 'Не знаю',
                action: 'checkAnswer',
                argument: '14/3'
              }
            ]
          ]
        });
        await transition('end');
      },
    }
  },

  actions: {
    checkAnswer: async ({ setState, state, edit, argument, send }) => {
      if (typeof argument === 'undefined') {
        argument = '1/1';
      } 
      
      const splitedArgument = argument.split('/');
      const day = splitedArgument[0];
      const selectedOption = splitedArgument[1];

      const answer = getAnswer(day, selectedOption);

      await edit({
        buttons: []
      });

      await send({
        message: answer.isCorrect ? '✅' : '❌',
      });


      if (answer.content.image) {
        await send({
          message: answer.content.text,
          image: answer.content.image
        });
      } else {
        await send({
          message: answer.content.text
        });
      }

      if (answer.content.anotherImage) {
        await send({
          message: answer.content.anotherText,
          image: answer.content.anotherImage
        });
      } else if (answer.content.anotherText) {
        await send({
          message: answer.content.anotherText
        });
      }

      await setState({ 
        day: day,
        answers: [...state.answers, answer.isCorrect]
      });

    }
  }
} as ICourse;